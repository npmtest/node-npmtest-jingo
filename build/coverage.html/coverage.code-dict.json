{"/home/travis/build/npmtest/node-npmtest-jingo/test.js":"/* istanbul instrument in package npmtest_jingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jingo/lib.npmtest_jingo.js":"/* istanbul instrument in package npmtest_jingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jingo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jingo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jingo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jingo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jingo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jingo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jingo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jingo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jingo.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jingo.__dirname + '/lib.npmtest_jingo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/jingo":"#!/usr/bin/env node\n\n/*\n * Jingo, wiki engine\n * http://github.com/claudioc/jingo\n *\n * Copyright 2016 Claudio Cicali <claudio.cicali@gmail.com>\n * Released under the MIT license\n */\nvar program = require('commander')\nvar tools = require('./lib/tools')\nvar config = require('./lib/config')\nvar http = require('http')\nvar fs = require('fs')\nvar os = require('os')\nvar semver = require('semver')\nvar pkg = require('./package')\n\nglobal.Git = require('./lib/gitmech')\n\nprogram.version(pkg.version)\n       .option('-c, --config <path>', 'Specify the config file')\n       .option('-#, --hash-string <string>', 'Create an hash for a string')\n       .option('-l, --local', 'Listen on localhost only')\n       .option('-s, --sample-config', 'Dumps a config file template and exits')\n       .parse(process.argv)\n\nif (program.sampleConfig) {\n  console.log(config.sample())\n  process.exit(0)\n}\n\nif (program.hashString) {\n  console.log(tools.hashify(program.hashString))\n  process.exit(0)\n}\n\nif (!program.config || !fs.existsSync(program.config)) {\n  program.help()\n  process.exit(-1)\n}\n\nif (!config.load(program.config)) {\n  console.log('Error: ' + config.getError())\n  process.exit(-1)\n}\n\nif (!config.validate()) {\n  console.log('Error: ' + config.getError())\n  process.exit(-1)\n}\n\nvar refspec = config.get('application').remote.split(/\\s+/)\n\nGit.setup(config.get('application').git,\n          config.get('application').repository,\n          config.get('application').docSubdir,\n          refspec, function (err, version) {\n            if (err) {\n              console.log(err)\n              process.exit(-1)\n            }\n\n            if (os.platform() === 'darwin' &&\n                !config.get('application').skipGitCheck &&\n                config.get('pages').title.fromFilename &&\n                !semver.satisfies(version, '>=1.8.5')) {\n              console.log('Your current setup uses the filename of the wiki page as the page title.')\n              console.log('Unfortunately this version of git (' + version + \".x) on OSX doesn't handle\")\n              console.log('very well non ASCII characters used in filenames, therefore I rather not start.')\n              console.log('You can continue anyway, setting `application.skipGitCheck` to true in the')\n              console.log('config file but you should better upgrade your git. Thank you.')\n              process.exit(-1)\n            }\n\n            start()\n          })\n\nfunction start () {\n  var app = require('./lib/app').initialize(config)\n\n  var listenAddr = process.env.NW_ADDR || ''\n  if (config.get('server').localOnly) {\n    listenAddr = 'localhost'\n  }\n\n  http.createServer(app).listen(config.get('server').port, listenAddr, function () {\n    console.log((new Date()) + ' - Jingo%sserver v%s listening on port %s', config.get('server').localOnly ? ' (local) ' : ' ', program.version(), config.get('server').port)\n  })\n\n  if (config.get('application').pushInterval && refspec.length > 0) {\n    setInterval(function () {\n      Git.pull(function (err) {\n        if (err) {\n          console.log('Error: ' + err)\n        } else {\n          Git.push(function (err) {\n            if (err) {\n              console.log('Error: ' + err)\n            }\n          })\n        }\n      })\n    }, config.get('application').pushInterval * 1000)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/tools.js":"var cryptoz = require('crypto')\n\nvar tools = {\n\n  isAuthorized: function (email, pattern, emptyEmailMatches) {\n    // Special case where the email is not returned by the backend authorization system\n    if (email === 'jingouser') {\n      return !!emptyEmailMatches\n    }\n\n    if (!email || !email.match(/\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b/i)) {\n      return false\n    }\n\n    if (!pattern || pattern.trim() === '') {\n      return true\n    }\n\n    var tests = pattern.split(',').map(function (str) {\n      return str.trim()\n    })\n    var expr\n    for (var i = 0; i < tests.length; i++) {\n      try {\n        expr = expr || !!email.match(new RegExp('^' + tests[i] + '$', 'i'))\n      } catch (e) { // Invalid regular expression\n        return false\n      }\n    }\n\n    return expr\n  },\n\n  hashify: function (str) {\n    var shasum = cryptoz.createHash('sha1')\n    shasum.update(str)\n    return shasum.digest('hex')\n  }\n}\n\nmodule.exports = tools\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/config.js":"var fs = require('fs')\nvar yaml = require('js-yaml')\nvar _ = require('lodash')\n\nmodule.exports = (function () {\n  var config\n  var error = ''\n\n  return {\n\n    load: function (filename) {\n      this.setup(yaml.load(fs.readFileSync(filename).toString()))\n\n      if (!config.application || !config.server) {\n        error = 'Missing `application` or `server` config section.'\n        return false\n      }\n\n      // Find any alien configuration options section\n      var aliens = _.difference(Object.keys(config), Object.keys(this.defaults))\n      if (aliens.length > 0) {\n        error = 'Unrecognized section name(s) ' + aliens.join(',')\n        return false\n      }\n\n      // Find any alien configuration options section name\n      var keys = Object.keys(this.defaults)\n      for (var i = 0; i < keys.length; i++) {\n        if (typeof config[keys[i]] === 'undefined') {\n          continue\n        }\n        aliens = _.difference(Object.keys(config[keys[i]]), Object.keys(this.defaults[keys[i]]))\n        if (aliens.length > 0) {\n          error = 'Unrecognized configuration option(s) ' + aliens.join(',') + ' in section ' + keys[i]\n          return false\n        }\n      }\n\n      return true\n    },\n\n    getError: function () {\n      return error\n    },\n\n    defaults: {\n\n      application: {\n        title: 'Jingo',\n        repository: '',\n        docSubdir: '',\n        remote: '',\n        pushInterval: 30,\n        secret: 'change me',\n        git: 'git',\n        skipGitCheck: false,\n        loggingMode: 1,\n        pedanticMarkdown: true,\n        gfmBreaks: true,\n        staticWhitelist: '/\\\\.png$/i, /\\\\.jpg$/i, /\\\\.gif$/i',\n        proxyPath: ''\n      },\n\n      authentication: {\n        google: {\n          enabled: true,\n          clientId: 'replace me with the real value',\n          clientSecret: 'replace me with the real value',\n          redirectURL: ''\n        },\n        github: {\n          enabled: false,\n          clientId: 'replace me with the real value',\n          clientSecret: 'replace me with the real value',\n          redirectURL: ''\n        },\n        ldap: {\n          enabled: false,\n          url: 'ldap://example.org:389',\n          bindDn: '',\n          bindCredentials: '',\n          searchBase: 'ou=people,dc=example,dc=org',\n          searchFilter: '(uid={{username}})',\n          searchAttributes: ''\n        },\n        // @deprecated, use local with just an user\n        alone: {\n          enabled: false,\n          username: '',\n          passwordHash: '',\n          email: ''\n        },\n        local: {\n          enabled: false,\n          accounts: [{\n            username: '',\n            passwordHash: '',\n            email: ''\n          }]\n        }\n      },\n\n      features: {\n        markitup: false,\n        codemirror: true\n      },\n\n      server: {\n        hostname: 'localhost',\n        port: process.env.PORT || 6067,\n        localOnly: false,\n        baseUrl: '',\n        // Since Jingo 1.6\n        CORS: {\n          enabled: false,\n          allowedOrigin: '*'\n        }\n      },\n\n      authorization: {\n        anonRead: true,\n        validMatches: '.+',\n        // Breaking changes in Jingo 1.5 (when this parameter has been added): the default for new servers is to NOT allow empty emails to validate\n        emptyEmailMatches: false\n      },\n\n      // Defaults for the pages key are compatible with Jingo < 1 (which means\n      // that the pages key is not present at all, thus we infer that we are in a Jingo < 1 setup)\n      // These defaults are different is the pages key is present.\n      // For example, if the index subkey is not present the default\n      // would be Home, not home.\n\n      // Please note that the combination of \"from filename\" and \"ascii only\"\n      // is not really an valid option (information will be probably lost regarding\n      // non ASCII only caracters)\n      pages: {\n        index: 'Home',\n        title: {\n          fromFilename: true,\n          fromContent: false,\n          asciiOnly: false,\n          lowercase: false\n        },\n        itemsPerPage: 10\n      },\n\n      customizations: {\n        sidebar: '_sidebar.md',\n        footer: '_footer.md',\n        style: '_style.css',\n        script: '_script.js'\n      }\n    },\n\n    // Ensure that all the key will have a sane default value\n    validate: function () {\n      config.application = _.extend({}, this.defaults.application, config.application)\n      config.application.pushInterval = (parseInt(config.application.pushInterval, 10) | 0)\n\n      config.authentication = _.extend({}, this.defaults.authentication, config.authentication)\n\n      if (!config.authentication.google.enabled &&\n        !config.authentication.github.enabled &&\n        !config.authentication.ldap.enabled &&\n        !config.authentication.alone.enabled &&\n        !config.authentication.local.enabled\n      ) {\n        error = 'No authentication method provided.'\n        return false\n      }\n\n      if (config.authentication.google.enabled && (!config.authentication.google.clientId || !config.authentication.google.clientSecret)) {\n        error = 'Invalid or missing authentication credentials for Google (clientId and/or clientSecret).'\n        return false\n      }\n\n      if (config.authentication.github.enabled && (!config.authentication.github.clientId || !config.authentication.github.clientSecret)) {\n        error = 'Invalid or missing authentication credentials for Github (clientId and/or clientSecret).'\n        return false\n      }\n\n      if (config.authentication.ldap.enabled && (!config.authentication.ldap.url || !config.authentication.ldap.searchBase || !config.authentication.ldap.searchFilter)) {\n        error = 'Invalid or missing config for LDAP (url and/or searchBase and/or searchFilter).'\n        return false\n      }\n\n      if (config.authentication.alone.enabled && config.authentication.local.enabled) {\n        error = 'Alone and Local authentication cannot be used at the same time'\n        return false\n      }\n\n      if (config.authentication.alone.enabled) {\n        console.warn('Deprecation: Alone authentication is deprecated and should be changed with Local.')\n      }\n\n      config.features = _.extend({}, this.defaults.features, config.features)\n\n      // For backward compatibility with version < 0.5, we set markitup as the\n      // default rich editor. For new installations, the default is codemirror\n      if (!config.features.markitup && !config.features.codemirror) {\n        config.features.markitup = true\n      }\n\n      if (config.features.markitup && config.features.codemirror) {\n        config.features.markitup = false\n      }\n\n      config.server = _.extend({}, this.defaults.server, config.server)\n\n      config.authorization = _.extend({}, this.defaults.authorization, config.authorization)\n\n      if (config.pages) {\n        config.pages = _.extend({}, this.defaults.pages, config.pages)\n\n        if (!config.pages.title.fromFilename && !config.pages.title.fromContent) {\n          config.pages.title.fromFilename = true\n        }\n\n        if (config.pages.title.fromFilename && config.pages.title.fromContent) {\n          config.pages.title.fromFilename = true\n        }\n      } else {\n        config.pages = _.extend({}, this.defaults.pages, config.pages)\n        // If the pages config key is not present, we desume that the user has\n        // upgraded Jingo but not the config file so we need to maintain the \"old\"\n        // behavior\n        config.pages.index = 'home'\n        config.pages.title.fromFilename = false\n        config.pages.title.fromContent = true\n        config.pages.title.asciiOnly = true\n      }\n\n      config.customizations = _.extend({}, this.defaults.customizations, config.customizations)\n\n      return true\n    },\n\n    get: function (key, useDefaults) {\n      if (!config && !useDefaults) {\n        throw new Error('The configuration has not been read and cannot be `get`')\n      }\n\n      if (!config && useDefaults) {\n        return this.defaults[key]\n      }\n\n      if (typeof key === 'undefined') {\n        return config\n      }\n\n      return config[key]\n    },\n\n    getProxyPath: function (override) {\n      var path = (override || this.get('application', true).proxyPath).trim()\n\n      // @TODO make sure the path is something that makes sense (?)\n      if (path.length === 0 || path === '/') {\n        return ''\n      }\n\n      if (path.charAt(0) !== '/') {\n        path = '/' + path\n      }\n\n      return path\n    },\n\n    // Manually set the config to the setup value\n    setup: function (setup) {\n      config = setup\n    },\n\n    // Dumps a sample config file\n    sample: function () {\n      var defs = _.clone(this.defaults)\n\n      // Removes deprecated auth method\n      delete defs.authentication.alone\n\n      return '---\\n' +\n        '# Configuration sample file for Jingo (YAML)\\n' +\n        yaml.dump(defs)\n    }\n  }\n}())\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/gitmech.js":"var path = require('path')\nvar childProcess = require('child_process')\nvar semver = require('semver')\nvar fs = require('fs')\n\nvar gitCommands, workTree, docSubdir\nvar gitENOENT = /fatal: (Path \"([^\"]+)\" does not exist in \"([0-9a-f]{40})\"|ambiguous argument \"([^\"]+)\": unknown revision or path not in the working tree.)/\n\n// Internal helper to talk to the git subprocess (spawn)\nfunction gitSpawn (commands, callback) {\n  commands = gitCommands.concat(commands)\n  var child = childProcess.spawn(gitMech.gitBin, commands, { cwd: workTree })\n  var stdout = []\n  var stderr = []\n  child.stdout.addListener('data', function (text) {\n    stdout[stdout.length] = text\n  })\n  child.stderr.addListener('data', function (text) {\n    stderr[stderr.length] = text\n  })\n  var exitCode\n  child.addListener('exit', function (code) {\n    exitCode = code\n  })\n  child.addListener('close', function () {\n    if (exitCode > 0 && stderr.length > 0) {\n      var err = new Error(gitMech.gitBin + ' ' + commands.join(' ') + '\\n' + join(stderr, 'utf8'))\n      if (gitENOENT.test(err.message)) {\n        err.errno = process.ENOENT\n      }\n      callback(err)\n      return\n    }\n\n    callback(null, join(stdout))\n  })\n  child.stdin.end()\n}\n\n// Internal helper to talk to the git subprocess (exec)\nfunction gitExec (commands, callback) {\n  commands = gitMech.gitBin + ' ' + gitCommands.concat(commands).join(' ')\n  // There is a limit at 200KB (increase it with maxBuffer option)\n  childProcess.exec(commands, { cwd: workTree }, function (error, stdout, stderr) {\n    if (error || stderr.length > 0) {\n      error = new Error(commands + '\\n' + stderr)\n      callback(error)\n      return\n    }\n    callback(null, stdout)\n  })\n}\n\nfunction join (arr) {\n  var result\n  var index = 0\n  var length\n\n  length = arr.reduce(function (l, b) {\n    return l + b.length\n  }, 0)\n  result = new Buffer(length)\n  arr.forEach(function (b) {\n    b.copy(result, index)\n    index += b.length\n  })\n\n  return result\n}\n\nvar gitMech = {\n\n  // FIXME: shouldPush should be a method which understands if the local repo is in sync with the remote\n  // BY default we assume the repo is dirty and needs a push\n  // git rev-list master...origin/master (if the output is empty, there is no need for a push)\n  shouldPush: true,\n\n  pulling: false,\n\n  pushing: false,\n\n  branch: 'master',\n\n  gitBin: 'git',\n\n  remote: '',\n\n  setup: function (gitBin, repoDir, repoDocSubdir, refspec, callback) {\n    this.gitBin = gitBin || 'git'\n\n    childProcess.exec(this.gitBin + ' --version', function (err, stdout, stderr) {\n      if (err !== null || stderr !== '') {\n        callback('Cannot run git (tried with ' + this.gitBin + ')')\n        return\n      }\n\n      var version = stdout.trim().split(' ')\n\n      if (version[0] !== 'git' || version.length < 3) {\n        callback('The provided git binary (' + this.gitBin + \") doesn't look as git to me.\")\n        return\n      }\n\n      version = version[2]\n\n      var splitted = version.split('.')\n      if (splitted.length > 3) {\n        version = splitted.slice(0, 3 - splitted.length).join('.')\n      }\n\n      if (splitted.length === 2) {\n        version = splitted.concat([0]).join('.')\n      }\n\n      if (!semver.valid(version)) {\n        callback('Unrecognized git semver (' + version + ')')\n        return\n      }\n\n      try {\n        fs.statSync(repoDir)\n      } catch (e) {\n        callback('Bad repository path (not exists): ' + repoDir)\n        return\n      }\n\n      docSubdir = repoDocSubdir.trim().replace(/^\\/|\\/$/g, '')\n      if (docSubdir !== '') {\n        docSubdir = docSubdir + '/'\n      }\n\n      try {\n        fs.statSync(repoDir + '/' + docSubdir)\n      } catch (e) {\n        callback('Bad document subdirectory (not exists): ' + repoDir + '/' + docSubdir)\n        return\n      }\n\n      try {\n        var gitDir = path.join(repoDir, '.git')\n        fs.statSync(gitDir)\n        workTree = repoDir\n        gitCommands = ['--git-dir=' + gitDir, '--work-tree=' + workTree]\n      } catch (e) {\n        callback('Bad repository path (not initialized): ' + repoDir)\n        return\n      }\n\n      if (refspec.length > 0) {\n        this.remote = refspec[0].trim()\n        this.branch = refspec[1] ? refspec[1].trim() : 'master'\n      }\n\n      callback(null, version)\n    }.bind(this))\n  },\n\n  absPath: function (path) {\n    return workTree + '/' + docSubdir + path\n  },\n\n  show: function (path, version, callback) {\n    gitSpawn(['show', version + ':' + docSubdir + path], function (err, data) {\n      if (err) {\n        callback(err)\n      } else {\n        callback(null, data.toString())\n      }\n    })\n  },\n\n  remoteExists: function (remote, callback) {\n    gitSpawn(['remote'], function (err, data) {\n      if (err) {\n        callback(err)\n        return\n      }\n      var remotes = (data ? data.toString().split('\\n') : [])\n      callback(null, remotes.indexOf(remote) !== -1)\n    })\n  },\n\n  pull: function (callback) {\n    if (this.pulling || this.remote === '' || this.branch === '') {\n      callback(null)\n      return\n    }\n\n    this.remoteExists(this.remote, function (err, exists) {\n      if (err) {\n        callback(err)\n        return\n      }\n      if (!exists) {\n        callback('Remote does not exist ' + '(' + this.remote + ')')\n        return\n      }\n      this.pulling = true\n\n      gitSpawn(['pull', this.remote, this.branch], function (err) {\n        this.pulling = false\n        if (err && err.toString().match(/^Error:/)) {\n          var lines = err.toString().split('\\n')\n          callback('Pull unsucessfull (' + lines[1] + ')')\n          return\n        }\n        callback(null)\n      }.bind(this))\n    }.bind(this))\n  },\n\n  push: function (callback) {\n    if (this.remote === '' || this.branch === '') {\n      callback(null)\n      return\n    }\n\n    // No commits, no push\n    if (this.pushing || !this.shouldPush) {\n      callback(null)\n      return\n    }\n\n    this.remoteExists(this.remote, function (err, exists) {\n      if (err) {\n        callback(err)\n        return\n      }\n      if (!exists) {\n        callback('Remote does not exist ' + '(' + this.remote + ')')\n        return\n      }\n\n      this.pushing = true\n\n      gitSpawn(['push', this.remote, this.branch], function (err) {\n        this.pushing = false\n        if (err && err.toString().match(/^Error:/)) {\n          var lines = err.toString().split('\\n')\n          callback('Push unsucessfull (' + lines[1] + ')')\n          return\n        }\n        this.shouldPush = false\n        callback(null)\n      }.bind(this))\n    }.bind(this))\n  },\n\n  log: function (path, version, howMany, callback) {\n    if (typeof howMany === 'function') {\n      callback = howMany\n      howMany = 1\n    }\n\n    gitSpawn(['log', '-' + howMany, '--reverse', '--no-notes', '--pretty=format:%h%n%H%n%an%n%ae%n%aD%n%ar%n%at%n%s', version, '--', docSubdir + path], function (err, data) {\n      var logdata = data ? data.toString().split('\\n') : []\n      var group\n      var metadata = []\n\n      if (err) {\n        callback(err)\n        return\n      }\n\n      for (var i = Math.floor(logdata.length / 8); i-- > 0;) {\n        group = logdata.slice(i * 8, (i + 1) * 8)\n        metadata.push({\n          name: path.replace('.md', ''),\n          hash: group[0],\n          hashRef: group[0],\n          fullhash: group[1],\n          author: group[2],\n          email: group[3],\n          date: group[4],\n          relDate: group[5],\n          timestamp: group[6],\n          subject: group[7]\n        })\n      }\n\n      if (metadata[0]) {\n        metadata[0].hashRef = '' // This can be used linking this version, but needs to be empty for HEAD\n      }\n\n      if (howMany === 1) {\n        metadata = metadata[0]\n      }\n\n      callback(null, metadata)\n    })\n  },\n\n  // Returns the hashes of commits on a file\n  hashes: function (path, howMany, callback) {\n    gitSpawn(['log', '-' + howMany, '--reverse', '--no-notes', '--pretty=format:%h', '--', docSubdir + path], function (err, data) {\n      var result = (data && !err) ? data.toString().split('\\n') : []\n      callback(err, result)\n    })\n  },\n\n  add: function (path, message, author, callback) {\n    gitSpawn(['add', docSubdir + path], function (err) {\n      if (err) {\n        console.log(err)\n        callback(err)\n      } else {\n        this.commit(path, message, author, callback)\n      }\n    }.bind(this))\n  },\n\n  rm: function (path, message, author, callback) {\n    gitSpawn(['rm', docSubdir + path], function (err) {\n      if (err) {\n        console.log(err)\n        callback(err)\n      } else {\n        this.commit(path, message, author, callback)\n      }\n    }.bind(this))\n  },\n\n  mv: function (path, newPath, message, author, callback) {\n    gitSpawn(['mv', '-f', docSubdir + path, docSubdir + newPath], function (err) {\n      if (err) {\n        console.log(err)\n        callback(err)\n      } else {\n        this.commit(path, message, author, callback)\n      }\n    }.bind(this))\n  },\n\n  commit: function (path, message, author, callback) {\n    var options\n    if (path) {\n      options = ['commit', '--author=\"' + author + '\"', '-m', message, docSubdir + path]\n    } else {\n      options = ['commit', '--author=\"' + author + '\"', '-am', message]\n    }\n    gitSpawn(options, function (err) {\n      this.shouldPush = true\n      callback(err)\n    }.bind(this))\n  },\n\n  grep: function (pattern, callback) {\n    // TODO decide for -w\n    var args = [ 'grep', '--no-color', '-F', '-n', '-i', '-I', pattern ]\n    if (docSubdir !== '') {\n      args.push(docSubdir)\n    }\n    gitSpawn(args, function (err, data) {\n      if (err) {\n        callback(err)\n        return\n      }\n      var result\n      if (data) {\n        result = data.toString().split('\\n')\n      } else {\n        result = []\n      }\n\n      // Search in the file names\n      gitSpawn([ 'ls-files', docSubdir + '*.md' ], function (err, data) {\n        if (data) {\n          var patternLower = pattern.toLowerCase()\n\n          data.toString().split('\\n').forEach(function (name) {\n            var nameLower = path.basename(name).toLowerCase()\n            if (nameLower.search(patternLower) >= 0) {\n              result.push(path.basename(name))\n            }\n          })\n        }\n\n        callback(err, result)\n      })\n    })\n  },\n\n  diff: function (path, revisions, callback) {\n    gitSpawn([ 'diff', '--no-color', '-b', revisions, '--', docSubdir + path ], function (err, data) {\n      callback(err, typeof data !== 'undefined' ? data.toString() : '')\n    })\n  },\n\n  lastMessage: function (path, revision, callback) {\n    gitSpawn(['log', '-1', revision, '--no-notes', '--pretty=format:%s', '--', docSubdir + path], function (err, data) {\n      callback(err, data.toString().trim())\n    })\n  },\n\n  ls: function (pattern, callback) {\n    gitExec([ 'ls-tree', '--name-only', '-r', 'HEAD', '--', docSubdir + pattern ], function (err, data) {\n      if (err) {\n        data = ''\n      }\n      callback(null, data.toString().split('\\n').filter(function (v) {\n        return v !== ''\n      }))\n    })\n  },\n\n  revert: function (path, revision, author, callback) {\n    gitExec(['checkout', revision, docSubdir + path], function (err, data) {\n      if (err) {\n        callback(err, ('' + data).toString().trim())\n        return\n      }\n      gitMech.commit(path, 'Reverted to ' + revision, author, function (err, data) {\n        callback(err, ('' + data).toString().trim())\n      })\n    })\n  }\n}\n\nmodule.exports = gitMech\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/app.js":"#!/usr/bin/env node\n\n/*\n * Jingo, wiki engine\n * http://github.com/claudioc/jingo\n *\n * Copyright 2014 Claudio Cicali <claudio.cicali@gmail.com>\n * Released under the MIT license\n */\n\nvar express = require('express')\nvar path = require('path')\nvar components = require('./components')\nvar wikiStatic = require('./wikistatic')\nvar favicon = require('serve-favicon')\nvar session = require('express-session')\nvar bodyParser = require('body-parser')\nvar expValidator = require('express-validator')\nvar cookieParser = require('cookie-parser')\nvar logger = require('morgan')\nvar program = require('commander')\nvar cookieSession = require('cookie-session')\nvar gravatar = require('gravatar')\nvar passport = require('passport')\nvar methodOverride = require('method-override')\nvar flash = require('express-flash')\n\nvar app\n\nmodule.exports.getInstance = function () {\n  if (!app) {\n    throw new Error('Cannot get an instance of an unitialized App')\n  }\n  return app\n}\n\nmodule.exports.initialize = function (config) {\n  app = express()\n\n  app.locals.config = config\n\n  app.locals.baseUrl = '//' + config.get('server').hostname + ':' + config.get('server').port\n\n  if (config.get('server').baseUrl === '') {\n    app.locals.baseUrl = '//' + config.get('server').hostname + ':' + config.get('server').port\n  } else {\n    app.locals.baseUrl = config.get('server').baseUrl\n  }\n\n  // View helpers\n  app.use(function (req, res, next) {\n    res.locals = {\n      get user () {\n        return req.user\n      },\n      get appTitle () {\n        return config.get('application').title\n      },\n      get proxyPath () {\n        return config.getProxyPath()\n      },\n      get jingoVersion () {\n        return program.version()\n      },\n      get authentication () {\n        return config.get('authentication')\n      },\n      isAnonymous: function () {\n        return !req.user\n      },\n      canSearch: function () {\n        return !!req.user || app.locals.config.get('authorization').anonRead\n      },\n      gravatar: function (email) {\n        return gravatar\n      },\n      get isAjax () {\n        return req.headers['x-requested-with'] && req.headers['x-requested-with'] === 'XMLHttpRequest'\n      }\n    }\n    next()\n  })\n\n  app.locals.coalesce = function (value, def) {\n    return typeof value === 'undefined' ? def : value\n  }\n\n  app.locals.pretty = true // Pretty HTML output from Jade\n\n  app.locals.hasSidebar = components.hasSidebar\n  app.locals.hasFooter = components.hasFooter\n  app.locals.hasCustomStyle = components.hasCustomStyle\n  app.locals.hasCustomScript = components.hasCustomScript\n  app.locals.hasFeature = function (feature) {\n    return !!app.locals.config.get('features')[feature]\n  }\n\n  if (components.hasCustomStyle()) {\n    console.log('Using custom style ' + config.get('customizations')['style'])\n  }\n\n  if (components.hasCustomScript()) {\n    console.log('Using custom script ' + config.get('customizations')['script'])\n  }\n\n  app.enable('trust proxy')\n  if (config.get('application').loggingMode) {\n    app.use(logger(config.get('application').loggingMode == 1 ? 'combined' : 'dev', {skip: function () { }})) // eslint-disable-line eqeqeq\n  }\n  app.use(favicon(path.join(__dirname + '/../', 'public', 'favicon.ico'))) // eslint-disable-line no-path-concat\n  app.use(bodyParser.urlencoded({extended: true, limit: '500kb'}))\n  app.use(methodOverride(function (req, res) {\n    if (req.body && typeof req.body === 'object' && '_method' in req.body) {\n      // look in urlencoded POST bodies and delete it\n      var method = req.body._method\n      delete req.body._method\n      return method\n    }\n  }))\n\n  app.use(express.static(path.join(__dirname + '/../', 'public'))) // eslint-disable-line no-path-concat\n  app.use(cookieParser())\n  app.use(cookieSession({\n    name: 'JingoSession',\n    keys: ['jingo'],\n    cookie: { maxAge: 30 * 24 * 60 * 60 * 1000 }\n  }))\n  app.use(session({ name: 'jingosid',\n                    secret: config.get('application').secret,\n                    cookie: { httpOnly: true },\n                    saveUninitialized: true,\n                    resave: true\n                  }))\n  app.use(flash())\n  app.use(expValidator())\n\n  app.set('views', __dirname + '/../views') // eslint-disable-line no-path-concat\n  app.set('view engine', 'jade')\n\n  // Read this before disabling it https://github.com/strongloop/express/pull/2813#issuecomment-159270428\n  app.set('x-powered-by', true)\n\n  app.use(function (req, res, next) {\n    res.locals._style = components.customStyle()\n    res.locals._script = components.customScript()\n\n    if (/^\\/auth\\//.test(req.url) ||\n        /^\\/misc\\//.test(req.url) ||\n        (/^\\/login/.test(req.url) && !config.get('authorization').anonRead)\n       ) {\n      return next()\n    }\n\n    components.sidebarAsync().then(function (content) {\n      res.locals._sidebar = content\n      return components.footerAsync()\n    }).then(function (content) {\n      res.locals._footer = content\n      return next()\n    }).catch(function (e) {\n      console.log(e)\n    })\n  })\n\n  app.use(passport.initialize())\n  app.use(passport.session())\n\n  app.locals.passport = passport\n\n  function requireAuthentication (req, res, next) {\n    if (!res.locals.user) {\n      res.redirect(res.locals.proxyPath + '/login')\n    } else {\n      next()\n    }\n  }\n\n  app.all('/pages/*', requireAuthentication)\n\n  if (!app.locals.config.get('authorization').anonRead) {\n    app.all('/wiki', requireAuthentication)\n    app.all('/wiki/*', requireAuthentication)\n    app.all('/search', requireAuthentication)\n  }\n\n  app.use('/wiki', wikiStatic.configure())\n\n  app.use(require('../routes/wiki'))\n     .use(require('../routes/pages'))\n     .use(require('../routes/search'))\n     .use(require('../routes/auth'))\n     .use(require('../routes/misc'))\n\n  // Server error\n  app.use(function (err, req, res, next) {\n    res.locals.title = '500 - Internal server error'\n    res.statusCode = 500\n    console.log(err)\n    res.render('500.jade', {\n      message: 'Sorry, something went wrong and I cannot recover. If you think this might be a bug in Jingo, please file a detailed report about what you were doing here: https://github.com/claudioc/jingo/issues . Thank you!',\n      error: err\n    })\n  })\n\n  return app\n}\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/components.js":"/* global Git */\nvar fs = require('fs')\nvar models = require('./models')\nvar Promiser = require('bluebird')\nvar renderer = require('./renderer')\nvar Configurable = require('./configurable')\n\nmodels.use(Git)\n\nfunction Component (name, file) {\n  this.name = name\n  this.file = file\n  this.cache = null\n  this.timer = 0\n  this._exists = false\n  Configurable.call(this)\n}\n\nComponent.prototype = Object.create(Configurable.prototype)\n\nComponent.prototype.exists = function () {\n  this.file = this.getConfig().customizations[this.name]\n\n  // The user can provide footer and sidebar without extension,\n  // so we add a default '.md' in that case. This test is 'good enough' for Jingo\n  if (this.file.indexOf('.') === -1) {\n    this.file += '.md'\n  }\n\n  if ((Date.now() - this.timer) > 30000) {\n    this.timer = Date.now()\n    this.cache = null\n  } else {\n    return this._exists\n  }\n\n  this._exists = fs.existsSync(Git.absPath(this.file))\n\n  if (!this._exists) {\n    this.cache = null\n  }\n\n  return this._exists\n}\n\nComponent.prototype.fetchAsync = function (cb) {\n  if (!this.exists()) {\n    cb && cb(null)\n    return\n  }\n\n  if (this.cache) {\n    cb && cb(null, this.cache)\n    return\n  }\n\n  var page = new models.Page(this.getConfig().customizations[this.name])\n\n  page.fetch().then(function () {\n    cb && cb(null, this.cache = renderer.render(page.content))\n  })\n}\n\nComponent.prototype.fetchSync = function () {\n  if (!this.exists()) {\n    return null\n  }\n\n  if (!this.cache) {\n    this.cache = fs.readFileSync(Git.absPath(this.file))\n  }\n\n  return this.cache\n}\n\nmodule.exports = (function () {\n  var components = [\n    new Component('sidebar'),\n    new Component('footer'),\n    new Component('style'),\n    new Component('script')\n  ]\n\n  function find (name) {\n    return components.filter(function (c) {\n      return c.name === name\n    })[0]\n  }\n\n  var publicMethods = {\n\n    expire: function (name) {\n      find(name).cache = null\n    },\n\n    hasSidebar: function () {\n      return find('sidebar').exists()\n    },\n\n    hasFooter: function () {\n      return find('footer').exists()\n    },\n\n    hasCustomStyle: function () {\n      return find('style').exists()\n    },\n\n    hasCustomScript: function () {\n      return find('script').exists()\n    },\n\n    sidebar: function (cb) {\n      find('sidebar').fetchAsync(cb)\n    },\n\n    footer: function (cb) {\n      find('footer').fetchAsync(cb)\n    },\n\n    customStyle: function () {\n      // Read sync because this info is needed by the layout\n      return find('style').fetchSync()\n    },\n\n    customScript: function () {\n      // Read sync because this info is needed by the layout\n      return find('script').fetchSync()\n    }\n  }\n\n  publicMethods.sidebarAsync = Promiser.promisify(publicMethods.sidebar, publicMethods)\n  publicMethods.footerAsync = Promiser.promisify(publicMethods.footer, publicMethods)\n\n  return publicMethods\n})()\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/models.js":"var Promiserr = require('bluebird')\nvar path = require('path')\nvar namer = require('./namer')\nvar fs = require('fs')\nvar Configurable = require('./configurable')\nvar locker = require('./locker')\n\nvar gitmech\n\nvar Configuration = function () {\n  Configurable.call(this)\n}\n\nConfiguration.prototype = Object.create(Configurable.prototype)\n\nvar configuration = new Configuration() // eslint-disable-line no-unused-vars\n\nfunction Page (name, revision) {\n  name = name || ''\n  this.setNames(name)\n  this.revision = revision || 'HEAD'\n  this.content = ''\n  this.title = ''\n  this.metadata = {}\n  this.error = ''\n  this.author = ''\n  this.lockedBy = null\n  this.hashes = []\n  this.lastCommand = ''\n  this.lastCommitMessage = ''\n  Configurable.call(this)\n}\n\nPage.prototype = Object.create(Configurable.prototype)\n\nPage.prototype.setNames = function (name) {\n  this.name = namer.unwikify(name.replace(/\\.md$/, ''))\n  this.wikiname = namer.wikify(this.name)\n  this.filename = this.wikiname + '.md'\n  this.pathname = gitmech.absPath(this.filename)\n}\n\nPage.prototype.remove = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n    gitmech.rm(this.filename, 'Page removed (' + this.wikiname + ')', this.author, function (err) {\n      if (err) {\n        reject(err)\n        return\n      }\n      resolve()\n    })\n  }.bind(this))\n}\n\nPage.prototype.renameTo = function (newName) {\n  var newFilename = newName + '.md'\n\n  return new Promiserr(function (resolve, reject) {\n    // Cannot rename if the file already exists\n    if (fs.existsSync(gitmech.absPath(newFilename))) {\n      reject()\n      return\n    }\n\n    gitmech.mv(this.filename,\n               newFilename,\n               'Page renamed (' + this.filename + ' => ' + newFilename + ')',\n               this.author,\n               function (err) {\n                 if (err) {\n                   reject()\n                 } else {\n                   this.setNames(newName)\n                   resolve()\n                 }\n               }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.exists = function () {\n  return fs.existsSync(this.pathname)\n}\n\nPage.prototype.save = function (message) {\n  message = message || ''\n\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    var defMessage = (this.exists() ? 'Content updated' : 'Page created') + ' (' + this.wikiname + ')'\n\n    message = (message.trim() === '') ? defMessage : message.trim()\n\n    var content = this.content\n\n    if (this.getConfig().pages.title.fromContent) {\n      content = '# ' + this.title + '\\n' + content\n    }\n\n    content = content.replace(/\\r\\n/gm, '\\n')\n\n    fs.writeFile(this.pathname, content, function (err) {\n      if (err) {\n        reject(err)\n        return\n      }\n\n      gitmech.add(this.filename, message, this.author, function (err) {\n        if (err) {\n          reject(err)\n          return\n        }\n\n        resolve(content)\n      })\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.urlFor = function (action) {\n  return Page.urlFor(this.wikiname, action, this.getProxyPath())\n}\n\nPage.urlFor = function (name, action, proxyPath) {\n  var wname = encodeURIComponent(name)\n  proxyPath = proxyPath || ''\n\n  var url = ''\n\n  switch (true) {\n\n    case action === 'show':\n      url = '/wiki/' + wname\n      break\n\n    case action === 'edit':\n      url = '/pages/' + wname + '/edit'\n      break\n\n    case action === 'edit error':\n      url = '/pages/' + wname + '/edit?e=1'\n      break\n\n    case action === 'edit put':\n      url = '/pages/' + wname\n      break\n\n    case action === 'revert':\n      url = '/pages/' + wname + '/revert'\n      break\n\n    case action === 'history':\n      url = '/wiki/' + wname + '/history'\n      break\n\n    case action === 'compare':\n      url = '/wiki/' + wname + '/compare'\n      break\n\n    case action === 'new':\n      url = '/pages/new/' + wname\n      break\n\n    case action === 'new error':\n      url = '/pages/new/' + wname + '?e=1'\n      break\n\n    default:\n      url = '/'\n      break\n  }\n\n  return proxyPath + url\n}\n\nPage.prototype.urlForShow = function (action) {\n  return this.urlFor('show')\n}\n\nPage.prototype.urlForEdit = function (action) {\n  return this.urlFor('edit')\n}\n\nPage.prototype.urlForEditWithError = function (action) {\n  return this.urlFor('edit error')\n}\n\nPage.prototype.urlForNewWithError = function (action) {\n  return this.urlFor('new error')\n}\n\nPage.prototype.urlForEditPut = function (action) {\n  return this.urlFor('edit put')\n}\n\nPage.prototype.urlForRevert = function (action) {\n  return this.urlFor('revert')\n}\n\nPage.prototype.urlForHistory = function (action) {\n  return this.urlFor('history')\n}\n\nPage.prototype.urlForCompare = function (action) {\n  return this.urlFor('compare')\n}\n\nPage.prototype.isIndex = function () {\n  return this.getConfig().pages.index === this.name\n}\n\nPage.prototype.isFooter = function () {\n  return this.name === '_footer'\n}\n\nPage.prototype.isSidebar = function () {\n  return this.name === '_sidebar'\n}\n\nPage.prototype.lock = function (user) {\n  var lock = locker.getLock(this.name)\n\n  if (lock && lock.user.asGitAuthor !== user.asGitAuthor) {\n    this.lockedBy = lock.user\n    return false\n  }\n\n  locker.lock(this.name, user)\n  this.lockedBy = user\n  return true\n}\n\nPage.prototype.unlock = function (user) {\n  this.lockedBy = null\n  locker.unlock(this.name)\n}\n\nPage.prototype.fetch = function (extended) {\n  if (!extended) {\n    return Promiserr.all([this.fetchContent(),\n                        this.fetchMetadata(),\n                        this.fetchHashes(1)\n                        ])\n  } else {\n    return Promiserr.all([this.fetchContent(),\n                        this.fetchMetadata(),\n                        this.fetchHashes(),\n                        this.fetchLastCommitMessage()])\n  }\n}\n\nPage.prototype.fetchContent = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.show(this.filename, this.revision, function (err, content) {\n      this.lastCommand = 'show'\n\n      content = content || ''\n\n      if (err) {\n        this.error = err\n      } else {\n        this.rawContent = content\n\n        if (content.length === 0 || this.getConfig().pages.title.fromFilename) {\n          this.title = this.name\n          this.content = content\n        } else {\n          // Retrieves the title from the first line of the content (and removes it from the actual content)\n          // By default Jingo (< 1.0) stores the title as the first line of the\n          // document, prefixed by a '#'\n          var lines = content.split('\\n')\n          this.title = lines[0].trim()\n\n          if (this.title.charAt(0) === '#') {\n            this.title = this.title.substr(1).trim()\n            this.content = lines.slice(1).join('\\n')\n          } else {\n            // Mmmmh... this file doesn't seem to follow Jingo's convention...\n            this.title = this.name\n            this.content = content\n          }\n        }\n      }\n\n      resolve()\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.fetchMetadata = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.log(this.filename, this.revision, function (err, metadata) {\n      this.lastCommand = 'log'\n\n      if (err) {\n        this.error = err\n      } else {\n        if (typeof metadata !== 'undefined') {\n          this.metadata = metadata\n        }\n      }\n\n      resolve()\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.fetchHashes = function (howmany) {\n  howmany = howmany || 2\n\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.hashes(this.filename, howmany, function (err, hashes) {\n      this.lastCommand = 'hashes'\n\n      if (err) {\n        this.error = err\n      } else {\n        this.hashes = hashes\n      }\n\n      resolve()\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.fetchLastCommitMessage = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.lastMessage(this.filename, 'HEAD', function (err, message) {\n      this.lastCommand = 'lastMessage'\n\n      if (err) {\n        this.error = err\n      } else {\n        this.lastCommitMessage = message\n      }\n\n      resolve()\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.fetchHistory = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.log(this.filename, 'HEAD', 30, function (err, history) {\n      this.lastCommand = 'log'\n\n      if (err) {\n        this.error = err\n      }\n\n      resolve(history)\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.fetchRevisionsDiff = function (revisions) {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    gitmech.diff(this.filename, revisions, function (err, diff) {\n      if (err) {\n        this.error = err\n      }\n\n      resolve(diff)\n    }.bind(this))\n  }.bind(this))\n}\n\nPage.prototype.revert = function () {\n  return new Promiserr(function (resolve, reject) {\n    if (this.error) {\n      resolve()\n      return\n    }\n\n    if (this.revision === 'HEAD') {\n      reject()\n      return\n    }\n\n    gitmech.revert(this.filename, this.revision, this.author, function (err, data) {\n      if (err) {\n        this.error = err\n        reject(err)\n        return\n      }\n      resolve(data)\n    }.bind(this))\n  }.bind(this))\n}\n\nfunction Pages () {\n  this.models = []\n  this.total = 0\n  Configurable.call(this)\n}\n\nPages.prototype = Object.create(Configurable.prototype)\n\nPages.prototype.fetch = function (pagen) {\n  return new Promiserr(function (resolve, reject) {\n    gitmech.ls('*.md', function (err, list) {\n      var model\n      var Promisers = []\n\n      if (err) {\n        reject(err)\n        return\n      }\n\n      var itemsPerPage = this.getConfig().pages.itemsPerPage\n\n      this.total = list.length\n      this.totalPages = Math.ceil(this.total / itemsPerPage)\n\n      if (pagen <= 0) {\n        pagen = 1\n      }\n      if (pagen > this.totalPages) {\n        pagen = this.totalPages\n      }\n\n      this.currentPage = pagen\n\n      // Read the stats from the fs to be able to sort the whole\n      // list before slicing the page out\n      var listWithData = list.map(function (page) {\n        var stats\n\n        try {\n          stats = fs.statSync(gitmech.absPath(page))\n        } catch (e) {\n          stats = null\n        }\n        return {\n          name: page,\n          stats: stats\n        }\n      })\n\n      listWithData.sort(function (a, b) {\n        return (a.stats !== null && b.stats !== null) ? b.stats.mtime.getTime() - a.stats.mtime.getTime() : 0\n      })\n\n      var offset = (pagen - 1) * itemsPerPage\n      var slice = listWithData.slice(offset, offset + itemsPerPage)\n\n      slice.forEach(function (data) {\n        var page = path.basename(data.name).replace(/\\.md$/, '')\n        model = new Page(page)\n        this.models.push(model)\n        Promisers.push(model.fetch(true))\n      }.bind(this))\n\n      Promiserr.all(Promisers).then(resolve)\n    }.bind(this))\n  }.bind(this))\n}\n\nvar models = {\n\n  Page: Page,\n\n  Pages: Pages,\n\n  use: function (git) {\n    gitmech = git\n  },\n\n  repositories: {\n\n    refresh: function (callback) {\n      gitmech.pull(function (err) {\n        callback(err)\n      })\n    }\n  },\n\n  pages: {\n\n    findString: function (string, callback) {\n      gitmech.grep(string, function (err, items) {\n        callback(err, items)\n      })\n    }\n  }\n}\n\nPromiserr.promisifyAll(models.pages)\nPromiserr.promisifyAll(models.repositories)\n\nmodule.exports = models\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/namer.js":"var tr = require('transliteration')\nvar Configurable = require('./configurable')\n\nvar wsReplacement = '-'\n\nfunction getWhitespaceReplacement () {\n  // For future improvements\n  return '-'\n}\n\nvar Namer = function () {\n  Configurable.call(this)\n}\n\nNamer.prototype = Object.create(Configurable.prototype)\n\nNamer.prototype.wikify = function (str) {\n  var ret = str\n\n  if (typeof ret !== 'string' || ret.trim() === '') {\n    return ''\n  }\n\n  wsReplacement = getWhitespaceReplacement()\n\n  var pc = this.getConfig().pages\n\n  // Replace < and > with '' (Gollum replaces it with '-')\n  ret = ret.replace(/[<>]/g, '')\n  // Replace / with '+' (Gollum replaces it with '')\n  ret = ret.replace(/\\//g, '+')\n\n  if (pc.title.asciiOnly) {\n    ret = tr(ret).replace(/[^a-zA-Z0-9\\- _]/g, '')\n  }\n\n  ret = ret.trim()\n\n  if (pc.title.lowercase) {\n    ret = ret.toLowerCase()\n  }\n\n  ret = ret.replace(/\\s/g, wsReplacement)\n\n  return ret\n}\n\n  // Not symmetric by any chance, but still better than nothing\nNamer.prototype.unwikify = function (str) {\n  var ret = str\n\n  if (typeof ret !== 'string' || ret.trim() === '') {\n    return ''\n  }\n\n  var pc = this.getConfig().pages\n\n  wsReplacement = getWhitespaceReplacement()\n\n  ret = ret.replace(new RegExp(wsReplacement, 'g'), ' ')\n\n  ret = ret.replace(/\\+/g, '/')\n\n  if (pc.title.lowercase) {\n    // \"something really hot\" => \"Something Really Hot\"\n    ret = ret.split(/\\b/).map(function (v) {\n      return v.slice(0, 1).toUpperCase() + v.slice(1)\n    }).join('')\n  }\n\n  return ret\n}\n\nmodule.exports = new Namer()\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/configurable.js":"var _ = require('lodash')\nvar configObject = require('./config')\n\nvar Configurable = function () {\n  this.config = {}\n  this.overrides = {}\n  this.configObject = configObject\n}\n\nConfigurable.prototype.configOverride = function (snippet) {\n  this.overrides = snippet ? _.extend(this.overrides, snippet) : {}\n}\n\nConfigurable.prototype.getConfig = function () {\n  try {\n    // The config has been already loaded somewhere else\n    this.config = _.clone(configObject.get(), true)\n  } catch (e) {\n    this.config = _.clone(configObject.defaults, true)\n  }\n\n  return _.merge(this.config, this.overrides)\n}\n\n// Provides a way to override the proxyPath\nConfigurable.prototype.getProxyPath = function () {\n  return configObject.getProxyPath(this.overrides.application && this.overrides.application.proxyPath)\n}\n\nmodule.exports = Configurable\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/locker.js":"\nvar Locker = {\n\n  locks: {},\n\n  purgeTime: 3600 * 1000,\n\n  lock: function (page, user) {\n    var d = new Date()\n    this.locks[page] = {\n      user: user,\n      ts: d.getTime() + (d.getTimezoneOffset() * 60 * 1000)\n    }\n  },\n\n  unlock: function (page) {\n    delete this.locks[page]\n  },\n\n  getLock: function (page) {\n    return this.locks[page] ? this.locks[page] : null\n  },\n\n  reset: function () {\n    this.locks = {}\n  },\n\n  count: function () {\n    return Object.keys(this.locks).length\n  },\n\n  purge: function () {\n    var d = new Date()\n    var now = d.getTime() + (d.getTimezoneOffset() * 60 * 1000)\n\n    for (var page in this.locks) {\n      if ((now - this.locks[page].ts) > this.purgeTime) {\n        this.unlock(page)\n      }\n    }\n  }\n}\n\nsetTimeout(function () {\n  Locker.purge()\n}, 3600 * 1000)\n\nmodule.exports = Locker\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/renderer.js":"var Marked = require('marked')\nvar cryptoz = require('crypto')\nvar Nsh = require('node-syntaxhighlighter')\nvar namer = require('./namer')\nvar Page = require('./models').Page\nvar directives = require('./directives')\nvar Configurable = require('./configurable')\n\nvar Configuration = function () {\n  Configurable.call(this)\n}\n\nConfiguration.prototype = Object.create(Configurable.prototype)\n\nvar configuration = new Configuration()\n\nvar mdRenderer = new Marked.Renderer()\n\nmdRenderer.code = function (code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang)\n    if (out !== null && out !== code) {\n      escaped = true\n      code = out\n    }\n  }\n\n  if (!lang) {\n    return '<code class=\"md-code\">' +\n           (escaped ? code : escape(code, true)) +\n           '\\n</code>'\n  }\n\n  return '<code class=\"md-code ' +\n    this.options.langPrefix +\n    escape(lang, true) +\n    '\">' +\n    (escaped ? code : escape(code, true)) +\n    '\\n</code>\\n'\n}\n\nMarked.setOptions({\n  gfm: true,\n  renderer: mdRenderer,\n  // pedantic: this is set on the render method\n  // breaks: this is set on the render method\n  tables: true,\n  smartLists: true,\n  sanitize: false, // To be able to add iframes\n  highlight: function (code, lang) {\n    lang = lang || 'text'\n    return Nsh.highlight(code, Nsh.getLanguage(lang) || Nsh.getLanguage('text'), {gutter: lang !== 'text'})\n  }\n})\n\nvar tagmap = {}\n\n// Yields the content with the rendered [[bracket tags]]\n// The rules are the same for Gollum https://github.com/github/gollum\nfunction extractTags (text) {\n  tagmap = {}\n\n  var matches = text.match(/\\[\\[(.+?)\\]\\]/g)\n  var tag\n  var id\n\n  if (matches) {\n    matches.forEach(function (match) {\n      match = match.trim()\n      tag = /(.?)\\[\\[(.+?)\\]\\](.?)/.exec(match)\n      if (tag[1] === \"'\") {\n        return\n      }\n      id = cryptoz.createHash('sha1').update(tag[2]).digest('hex')\n      tagmap[id] = tag[2]\n      text = text.replace(tag[0], id)\n    })\n  }\n  return text\n}\n\nfunction evalTags (text) {\n  var parts,\n    name,\n    url,\n    pageName,\n    re\n\n  for (var k in tagmap) {\n    if (tagmap.hasOwnProperty(k)) {\n      parts = tagmap[k].split('|')\n      name = pageName = parts[0]\n      if (parts[1]) {\n        pageName = parts[1]\n      }\n      url = Page.urlFor(namer.wikify(pageName), 'show', configuration.configObject.getProxyPath())\n\n      tagmap[k] = '<a class=\"internal\" href=\"' + url + '\">' + name + '</a>'\n    }\n  }\n\n  for (k in tagmap) {\n    if (tagmap.hasOwnProperty(k)) {\n      re = new RegExp(k, 'g')\n      text = text.replace(re, tagmap[k])\n    }\n  }\n\n  return text\n}\n\nvar directiveMap = directives.directiveMap\n\nfunction applyDirectives (text) {\n  var matches = text.match(/\\{\\{([^}]*)\\}\\}/g)\n\n  if (matches) {\n    matches.forEach(function (match) {\n      var directiveString = /\\{\\{([^}]*)\\}\\}/.exec(match)[1]\n      var directiveSplit = directiveString.split('\\n')\n      var directive = directiveSplit[0]\n      var args = directiveSplit.slice(1).join('\\n')\n      if (directive in directiveMap) {\n        text = text.replace(match, directiveMap[directive](text, args))\n      }\n    })\n  }\n  return text\n}\n\nvar Renderer = {\n\n  render: function (content) {\n    Marked.setOptions({\n      pedantic: configuration.getConfig().application.pedanticMarkdown,\n      breaks: configuration.getConfig().application.gfmBreaks\n    })\n\n    var text = extractTags(content)\n    text = evalTags(text)\n    text = applyDirectives(text)\n    return Marked(text)\n  }\n\n}\n\nmodule.exports = Renderer\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/directives.js":"var directives = {\n  TOC: function (text) {\n    var toc = require('markdown-toc')\n    text = text.split('\\n').slice(1).join('\\n')\n    return toc(text, {slugify: function (str) {\n      return str.toLowerCase().replace(/[^\\w]+/g, '-')\n    }}).content\n  }\n}\n\nmodule.exports = {\n  directiveMap: directives\n}\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/wikistatic.js":"/* global Git */\nvar Configurable = require('./configurable')\nvar ecstatic = require('ecstatic')\n\nvar WikiStatic = function () {\n  Configurable.call(this)\n}\n\nWikiStatic.prototype = Object.create(Configurable.prototype)\n\nWikiStatic.prototype.configure = function () {\n  var wikiRoot = Git.absPath('')\n  var middleware = ecstatic({ root: wikiRoot, handleError: false })\n\n  var config = this.getConfig().application\n  var whiteList = config.staticWhitelist\n  var patterns = whiteList.split(',')\n  var regexpList = []\n\n  for (var i = 0; i < patterns.length; i++) {\n    var pattern = patterns[i].trim()\n    var res = /^\\/(.*)\\/(.*)/.exec(pattern)\n\n    if (res) {\n      try {\n        var regexp = RegExp(res[1], res[2])\n        regexpList.push(regexp)\n      } catch (e) {\n        console.log('Warning: ignoring bad whitelist pattern: ' + pattern)\n      }\n    } else {\n      console.log('Warning: ignoring bad whitelist pattern: ' + pattern)\n    }\n  }\n\n  return function (req, res, next) {\n    if (regexpList.some(function (regexp) {\n      return regexp.test(req.url)\n    })) {\n      // The requested URL matches some pattern on the white list, serve it up!\n      middleware(req, res, next)\n    } else {\n      next()\n    }\n  }\n}\n\nmodule.exports = new WikiStatic()\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/lib/cors-enabler.js":"var cors = require('cors')\nvar app = require('./app').getInstance()\n\nvar corsConfig = {\n  origin: function (origin, cb) {\n    var cfg = app.locals.config.get('server').CORS\n    var allowed = !!(cfg && cfg.enabled && (origin === cfg.allowedOrigin || cfg.allowedOrigin === '*'))\n    cb(null, allowed)\n  },\n  methods: ['GET']\n}\n\nmodule.exports = cors(corsConfig)\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/routes/auth.js":"var router = require('express').Router()\nvar app = require('../lib/app').getInstance()\nvar _ = require('lodash')\nvar passportLocal = require('passport-local')\nvar passportGoogle = require('passport-google-oauth')\nvar passportGithub = require('passport-github').Strategy\nvar tools = require('../lib/tools')\n\nvar auth = app.locals.config.get('authentication')\n\n// Additional LDAP support only if needed\nvar passportLDAP\nif (auth.ldap.enabled) {\n  passportLDAP = require('passport-ldapauth')\n}\n\nvar passport = app.locals.passport\nvar proxyPath = app.locals.config.getProxyPath()\nvar redirectURL\n\nrouter.get('/login', _getLogin)\nrouter.get('/logout', _getLogout)\nrouter.post('/login', passport.authenticate('local', {\n  successRedirect: proxyPath + '/auth/done',\n  failureRedirect: proxyPath + '/login',\n  failureFlash: true\n}))\nrouter.get('/auth/done', _getAuthDone)\n\nrouter.get('/auth/google', passport.authenticate('google', {\n  scope: ['https://www.googleapis.com/auth/userinfo.email', 'https://www.googleapis.com/auth/userinfo.profile']\n}))\n\nrouter.get('/oauth2callback', passport.authenticate('google', {\n  successRedirect: proxyPath + '/auth/done',\n  failureRedirect: proxyPath + '/login'\n}))\n\nrouter.get('/auth/github', passport.authenticate('github'))\nrouter.get('/auth/github/callback', passport.authenticate('github', {\n  successRedirect: proxyPath + '/auth/done',\n  failureRedirect: proxyPath + '/login'\n}))\n\nif (auth.ldap.enabled) {\n  router.post('/auth/ldap', passport.authenticate('ldapauth', {\n    successRedirect: proxyPath + '/auth/done',\n    failureRedirect: proxyPath + '/login',\n    failureFlash: true\n  }))\n}\n\nif (auth.google.enabled) {\n  redirectURL = auth.google.redirectURL || app.locals.baseUrl + '/oauth2callback'\n  passport.use(new passportGoogle.OAuth2Strategy({\n    clientID: auth.google.clientId,\n    clientSecret: auth.google.clientSecret,\n    // I will leave the horrible name as the default to make the painful creation\n    // of the client id/secret simpler\n    callbackURL: redirectURL\n  },\n\n    function (accessToken, refreshToken, profile, done) {\n      usedAuthentication('google')\n      done(null, profile)\n    }\n  ))\n}\n\nif (auth.github.enabled) {\n  redirectURL = auth.github.redirectURL || app.locals.baseUrl + '/auth/github/callback'\n\n  // Register a new Application with Github https://github.com/settings/applications/new\n  // Authorization callback URL /auth/github/callback\n  passport.use(new passportGithub({ // eslint-disable-line new-cap\n    clientID: auth.github.clientId,\n    clientSecret: auth.github.clientSecret,\n    callbackURL: redirectURL\n  },\n    function (accessToken, refreshToken, profile, done) {\n      usedAuthentication('github')\n      done(null, profile)\n    }\n  ))\n}\n\nif (auth.ldap.enabled) {\n  passport.use(new passportLDAP({ // eslint-disable-line new-cap\n    server: {\n      url: auth.ldap.url,\n      bindDn: auth.ldap.bindDn,\n      bindCredentials: auth.ldap.bindCredentials,\n      searchBase: auth.ldap.searchBase,\n      searchFilter: auth.ldap.searchFilter,\n      searchAttributes: auth.ldap.searchAttributes\n    }\n  },\n    function (profile, done) {\n      usedAuthentication('ldap')\n      done(null, profile)\n    }\n  ))\n}\n\nif (auth.alone.enabled) {\n  passport.use(new passportLocal.Strategy(\n\n    function (username, password, done) {\n      var user = {\n        displayName: auth.alone.username,\n        email: auth.alone.email || ''\n      }\n\n      if (username.toLowerCase() !== auth.alone.username.toLowerCase() || tools.hashify(password) !== auth.alone.passwordHash) {\n        return done(null, false, { message: 'Incorrect username or password' })\n      }\n\n      usedAuthentication('alone')\n\n      return done(null, user)\n    }\n  ))\n}\n\nif (auth.local.enabled) {\n  passport.use(new passportLocal.Strategy(\n\n    function (username, password, done) {\n      var wantedUsername = username.toLowerCase()\n      var wantedPasswordHash = tools.hashify(password)\n\n      var foundUser = _.find(auth.local.accounts, function (account) {\n        return account.username.toLowerCase() === wantedUsername &&\n            account.passwordHash.toLowerCase() === wantedPasswordHash.toLowerCase()\n      })\n\n      if (!foundUser) {\n        return done(null, false, { message: 'Incorrect username or password' })\n      }\n\n      usedAuthentication('local')\n\n      return done(null, {\n        displayName: foundUser.username,\n        email: foundUser.email || ''\n      })\n    }\n  ))\n}\n\nfunction usedAuthentication (name) {\n  for (var a in auth) {\n    if (auth.hasOwnProperty(a)) {\n      auth[a].used = (a === name)\n    }\n  }\n}\n\npassport.serializeUser(function (user, done) {\n  done(null, user)\n})\n\npassport.deserializeUser(function (user, done) {\n  if (user.emails && user.emails.length > 0) { // Google\n    user.email = user.emails[0].value\n    delete user.emails\n  }\n\n  if (!user.displayName && user.username) {\n    user.displayName = user.username\n  }\n\n  // for ldap auth\n  if (auth.ldap.enabled) {\n    if (!user.displayName && user.uid) {\n      user.displayName = user.uid\n    }\n    if (!user.email && user.mail) {\n      user.email = user.mail\n    }\n  }\n\n  if (!user.email) {\n    user.email = 'jingouser'\n  }\n\n  user.asGitAuthor = user.displayName + ' <' + user.email + '>'\n  done(undefined, user)\n})\n\nfunction _getLogout (req, res) {\n  req.logout()\n  req.session = null\n  res.redirect(proxyPath + '/')\n}\n\nfunction _getAuthDone (req, res) {\n  if (!res.locals.user) {\n    res.redirect(proxyPath + '/')\n    return\n  }\n\n  if (!auth.alone.used &&\n      !auth.local.used &&\n      !tools.isAuthorized(res.locals.user.email,\n                          app.locals.config.get('authorization').validMatches,\n                          app.locals.config.get('authorization').emptyEmailMatches)) {\n    req.logout()\n    req.session = null\n    res.statusCode = 403\n    res.end('<h1>Forbidden</h1>')\n  } else {\n    var dst = req.session.destination || proxyPath + '/'\n    delete req.session.destination\n    res.redirect(dst)\n  }\n}\n\nfunction _getLogin (req, res) {\n  req.session.destination = req.query.destination\n\n  if (req.session.destination === '/login') {\n    req.session.destination = '/'\n  }\n\n  res.locals.errors = req.flash()\n\n  res.render('login', {\n    title: app.locals.config.get('application').title,\n    auth: auth\n  })\n}\n\nmodule.exports = router\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/routes/misc.js":"/* global Git */\nvar router = require('express').Router()\nvar renderer = require('../lib/renderer')\nvar fs = require('fs')\nvar models = require('../lib/models')\n\nmodels.use(Git)\n\nrouter.get('/misc/syntax-reference', _getSyntaxReference)\nrouter.post('/misc/preview', _postPreview)\nrouter.get('/misc/existence', _getExistence)\n\nfunction _getSyntaxReference (req, res) {\n  res.render('syntax')\n}\n\nfunction _postPreview (req, res) {\n  res.render('preview', {\n    content: renderer.render(req.body.data)\n  })\n}\n\nfunction _getExistence (req, res) {\n  if (!req.query.data) {\n    res.send(JSON.stringify({data: []}))\n    return\n  }\n\n  var result = []\n  var page\n  var n = req.query.data.length\n\n  req.query.data.forEach(function (pageName, idx) {\n    (function (name, index) {\n      page = new models.Page(name)\n      if (!fs.existsSync(page.pathname)) {\n        result.push(name)\n      }\n      if (index === (n - 1)) {\n        res.send(JSON.stringify({data: result}))\n      }\n    }(pageName, idx))\n  })\n}\n\nrouter.all('*', function (req, res) {\n  res.locals.title = '404 - Not found'\n  res.statusCode = 404\n  res.render('404.jade')\n})\n\nmodule.exports = router\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/routes/pages.js":"/* global Git */\n\nvar router = require('express').Router()\nvar namer = require('../lib/namer')\nvar app = require('../lib/app').getInstance()\nvar models = require('../lib/models')\nvar components = require('../lib/components')\n\nmodels.use(Git)\n\nrouter.get('/pages/new', _getPagesNew)\nrouter.get('/pages/new/:page', _getPagesNew)\nrouter.get('/pages/:page/edit', _getPagesEdit)\nrouter.post('/pages', _postPages)\nrouter.put('/pages/:page', _putPages)\nrouter.delete('/pages/:page', _deletePages)\nrouter.get('/pages/:page/revert/:version', _getRevert)\n\nvar pagesConfig = app.locals.config.get('pages')\nvar proxyPath = app.locals.config.getProxyPath()\n\nfunction _deletePages (req, res) {\n  var page = new models.Page(req.params.page)\n\n  if (page.isIndex() || !page.exists()) {\n    req.session.notice = 'The page cannot be deleted.'\n    res.redirect(proxyPath + '/')\n    return\n  }\n\n  page.author = req.user.asGitAuthor\n\n  page.remove().then(function () {\n    page.unlock()\n\n    if (page.isFooter()) {\n      app.locals._footer = null\n    }\n\n    if (page.isSidebar()) {\n      app.locals._sidebar = null\n    }\n\n    req.session.notice = 'The page `' + page.wikiname + '` has been deleted.'\n    res.redirect(proxyPath + '/')\n  })\n}\n\nfunction _getPagesNew (req, res) {\n  var page\n  var title = ''\n\n  if (req.params.page) {\n    // This is not perfect, unfortunately\n    title = namer.unwikify(req.params.page)\n    page = new models.Page(title)\n    if (page.exists()) {\n      res.redirect(page.urlForShow())\n      return\n    }\n  }\n\n  res.locals.errors = req.session.errors\n  res.locals.formData = req.session.formData || {}\n  delete req.session.errors\n  delete req.session.formData\n\n  res.render('create', {\n    title: 'Jingo – Create page ' + title,\n    pageTitle: title,\n    pageName: page ? page.wikiname : ''\n  })\n}\n\nfunction _postPages (req, res) {\n  var errors,\n    pageName\n\n  if (pagesConfig.title.fromFilename) {\n    // pageName (from url) is not considered\n    pageName = req.body.pageTitle\n  } else {\n    // pageName (from url) is more important\n    pageName = (namer.unwikify(req.body.pageName) || req.body.pageTitle)\n  }\n\n  var page = new models.Page(pageName)\n\n  req.check('pageTitle', 'The page title cannot be empty').notEmpty()\n  req.check('content', 'The page content cannot be empty').notEmpty()\n\n  errors = req.validationErrors()\n\n  if (errors) {\n    req.session.errors = errors\n    // If the req.body is too big, the cookie session-store will crash,\n    // logging out the user. For this reason we use the sessionStorage\n    // on the client to save the body when submitting\n    //    req.session.formData = req.body;\n    req.session.formData = {\n      pageTitle: req.body.pageTitle\n    }\n    res.redirect(page.urlForNewWithError())\n    return\n  }\n\n  req.sanitize('pageTitle').trim()\n  req.sanitize('content').trim()\n\n  if (page.exists()) {\n    req.session.errors = [{msg: 'A document with this title already exists'}]\n    res.redirect(page.urlFor('new'))\n    return\n  }\n\n  page.author = req.user.asGitAuthor\n  page.title = req.body.pageTitle\n  page.content = req.body.content\n\n  page.save().then(function () {\n    req.session.notice = 'The page has been created. <a href=\"' + page.urlForEdit() + '\">Edit it again?</a>'\n    res.redirect(page.urlForShow())\n  }).catch(function (err) {\n    res.locals.title = '500 - Internal server error'\n    res.statusCode = 500\n    console.log(err)\n    res.render('500.jade', {\n      message: 'Sorry, something went wrong and I cannot recover. If you think this might be a bug in Jingo, please file a detailed report about what you were doing here: https://github.com/claudioc/jingo/issues . Thank you!',\n      error: err\n    })\n  })\n}\n\nfunction _putPages (req, res) {\n  var errors,\n    page\n\n  page = new models.Page(req.params.page)\n\n  req.check('pageTitle', 'The page title cannot be empty').notEmpty()\n  req.check('content', 'The page content cannot be empty').notEmpty()\n\n  errors = req.validationErrors()\n\n  if (errors) {\n    fixErrors()\n    return\n  }\n\n  // Highly unluckly (someone deleted the page we were editing)\n  if (!page.exists()) {\n    req.session.notice = 'The page does not exist anymore.'\n    res.redirect(proxyPath + '/')\n    return\n  }\n\n  req.sanitize('pageTitle').trim()\n  req.sanitize('content').trim()\n  req.sanitize('message').trim()\n\n  page.author = req.user.asGitAuthor\n\n  // Test if the user changed the name of the page and try to rename the file\n  // If the title is from filename, we cannot overwrite an existing filename\n  // If the title is from content, we never rename a file and the problem does not exist\n  if (app.locals.config.get('pages').title.fromFilename &&\n      page.name.toLowerCase() !== req.body.pageTitle.toLowerCase()) {\n    page.renameTo(req.body.pageTitle)\n          .then(savePage)\n          .catch(function (ex) {\n            errors = [{\n              param: 'pageTitle',\n              msg: 'A page with this name already exists.',\n              value: ''\n            }]\n            fixErrors()\n          })\n  } else {\n    savePage()\n  }\n\n  function savePage () {\n    page.title = req.body.pageTitle\n    page.content = req.body.content\n    page.save(req.body.message).then(function () {\n      page.unlock()\n\n      if (page.name === '_footer') {\n        components.expire('footer')\n      }\n\n      if (page.name === '_sidebar') {\n        components.expire('sidebar')\n      }\n\n      req.session.notice = 'The page has been updated. <a href=\"' + page.urlForEdit() + '\">Edit it again?</a>'\n      res.redirect(page.urlForShow())\n    }).catch(function (err) {\n      res.locals.title = '500 - Internal server error'\n      res.statusCode = 500\n      console.log(err)\n      res.render('500.jade', {\n        message: 'Sorry, something went wrong and I cannot recover. If you think this might be a bug in Jingo, please file a detailed report about what you were doing here: https://github.com/claudioc/jingo/issues . Thank you!',\n        error: err\n      })\n    })\n  }\n\n  function fixErrors () {\n    req.session.errors = errors\n    // If the req.body is too big, the cookie session-store will crash,\n    // logging out the user. For this reason we use the sessionStorage\n    // on the client to save the body when submitting\n    //    req.session.formData = req.body;\n    req.session.formData = {\n      pageTitle: req.body.pageTitle,\n      message: req.body.message\n    }\n    res.redirect(page.urlForEditWithError())\n  }\n}\n\nfunction _getPagesEdit (req, res) {\n  var page = new models.Page(req.params.page)\n  var warning\n\n  if (!page.lock(req.user)) {\n    warning = 'Warning: this page is probably being edited by ' + page.lockedBy.displayName\n  }\n\n  models.repositories.refreshAsync().then(function () {\n    return page.fetch()\n  }).then(function () {\n    if (!req.session.formData) {\n      res.locals.formData = {\n        pageTitle: page.title,\n        content: page.content\n      }\n    } else {\n      res.locals.formData = req.session.formData\n      // FIXME remove this when the sessionStorage fallback will be implemented\n      if (!res.locals.formData.content) {\n        res.locals.formData.content = page.content\n      }\n    }\n\n    res.locals.errors = req.session.errors\n\n    delete req.session.errors\n    delete req.session.formData\n\n    res.render('edit', {\n      title: 'Jingo – Edit page ' + page.title,\n      page: page,\n      warning: warning\n    })\n  })\n}\n\nfunction _getRevert (req, res) {\n  var page = new models.Page(req.params.page, req.params.version)\n\n  page.author = req.user.asGitAuthor\n\n  page.fetch().then(function () {\n    if (!page.error) {\n      page.revert()\n      res.redirect(page.urlFor('history'))\n    } else {\n      res.locals.title = '500 - Internal Server Error'\n      res.statusCode = 500\n      res.render('500.jade')\n      return\n    }\n  })\n}\n\nmodule.exports = router\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/routes/search.js":"/* global Git */\n\nvar router = require('express').Router()\nvar path = require('path')\nvar corsEnabler = require('../lib/cors-enabler')\nvar models = require('../lib/models')\n\nmodels.use(Git)\n\nrouter.options('/search', corsEnabler)\nrouter.get('/search', corsEnabler, _getSearch)\n\nfunction _getSearch (req, res) {\n  var record\n\n  res.locals.matches = []\n\n  if (req.query.term) {\n    res.locals.term = req.query.term.trim()\n  } else {\n    res.locals.term = ''\n  }\n\n  if (res.locals.term.length === 0) {\n    renderResults()\n    return\n  }\n\n  if (res.locals.term.length < 2) {\n    res.locals.warning = 'Search string is too short.'\n    renderResults()\n  } else {\n    try {\n      new RegExp(res.locals.term) // eslint-disable-line no-new\n    } catch (e) {\n      res.locals.warning = 'The format of the search string is invalid.'\n      renderResults()\n      return\n    }\n\n    models.pages.findStringAsync(res.locals.term).then(function (items) {\n      items.forEach(function (item) {\n        if (item.trim() !== '') {\n          record = item.split(':')\n          res.locals.matches.push({\n            pageName: path.basename(record[0].replace(/\\.md$/, '')),\n            line: record[1] ? ', L' + record[1] : '',\n            text: record.slice(2).join('')\n          })\n        }\n      })\n\n      renderResults()\n    })\n  }\n\n  function renderResults () {\n    res.render('search', {\n      title: 'Search results'\n    })\n  }\n}\n\nmodule.exports = router\n","/home/travis/build/npmtest/node-npmtest-jingo/node_modules/jingo/routes/wiki.js":"/* global Git */\n\nvar router = require('express').Router()\nvar renderer = require('../lib/renderer')\nvar models = require('../lib/models')\nvar corsEnabler = require('../lib/cors-enabler')\nvar app = require('../lib/app').getInstance()\n\nvar proxyPath = app.locals.config.getProxyPath()\n\nmodels.use(Git)\n\nrouter.get('/', _getIndex)\nrouter.get('/wiki', _getWiki)\nrouter.options('/wiki/:page', corsEnabler)\nrouter.get('/wiki/:page', corsEnabler, _getWikiPage)\nrouter.get('/wiki/:page/history', _getHistory)\nrouter.get('/wiki/:page/:version', _getWikiPage)\nrouter.get('/wiki/:page/compare/:revisions', _getCompare)\n\nfunction _getHistory (req, res) {\n  var page = new models.Page(req.params.page)\n\n  page.fetch().then(function () {\n    return page.fetchHistory()\n  }).then(function (history) {\n    // FIXME better manage an error here\n    if (!page.error) {\n      res.render('history', {\n        items: history,\n        title: 'History of ' + page.name,\n        page: page\n      })\n    } else {\n      res.locals.title = '404 - Not found'\n      res.statusCode = 404\n      res.render('404.jade')\n    }\n  })\n}\n\nfunction _getWiki (req, res) {\n  var items = []\n  var pagen = 0 | req.query.page\n\n  var pages = new models.Pages()\n\n  pages.fetch(pagen).then(function () {\n    pages.models.forEach(function (page) {\n      if (!page.error) {\n        items.push({\n          page: page,\n          hashes: page.hashes.length === 2 ? page.hashes.join('..') : ''\n        })\n      }\n    })\n\n    res.render('list', {\n      items: items,\n      title: 'All the pages',\n      pageNumbers: Array.apply(null, Array(pages.totalPages)).map(function (x, i) {\n        return i + 1\n      }),\n      pageCurrent: pages.currentPage\n    })\n  }).catch(function (ex) {\n    console.log(ex)\n  })\n}\n\nfunction _getWikiPage (req, res) {\n  var page = new models.Page(req.params.page, req.params.version)\n\n  page.fetch().then(function () {\n    if (!page.error) {\n      res.locals.canEdit = true\n      if (page.revision !== 'HEAD' && page.revision !== page.hashes[0]) {\n        res.locals.warning = \"You're not reading the latest revision of this page, which is \" + \"<a href='\" + page.urlForShow() + \"'>here</a>.\"\n        res.locals.canEdit = false\n      }\n\n      res.locals.notice = req.session.notice\n      delete req.session.notice\n\n      res.render('show', {\n        page: page,\n        title: app.locals.config.get('application').title + ' – ' + page.title,\n        content: renderer.render('# ' + page.title + '\\n' + page.content)\n      })\n    } else {\n      if (req.user) {\n        // Try sorting out redirect loops with case insentive fs\n        // Path 'xxxxx.md' exists on disk, but not in 'HEAD'.\n        if (/but not in 'HEAD'/.test(page.error)) {\n          page.setNames(page.name.slice(0, 1).toUpperCase() + page.name.slice(1))\n        }\n        res.redirect(page.urlFor('new'))\n      } else {\n        // Special case for the index page, anonymous user and an empty docbase\n        if (page.isIndex()) {\n          res.render('welcome', {\n            title: 'Welcome to ' + app.locals.config.get('application').title\n          })\n        } else {\n          res.locals.title = '404 - Not found'\n          res.statusCode = 404\n          res.render('404.jade')\n          return\n        }\n      }\n    }\n  })\n}\n\nfunction _getCompare (req, res) {\n  var revisions = req.params.revisions\n\n  var page = new models.Page(req.params.page)\n\n  page.fetch().then(function () {\n    return page.fetchRevisionsDiff(revisions)\n  }).then(function (diff) {\n    if (!page.error) {\n      var lines = []\n      diff.split('\\n').slice(4).forEach(function (line) {\n        if (line.slice(0, 1) !== '\\\\') {\n          lines.push({\n            text: line,\n            ldln: leftDiffLineNumber(0, line),\n            rdln: rightDiffLineNumber(0, line),\n            className: lineClass(line)\n          })\n        }\n      })\n\n      var revs = revisions.split('..')\n      res.render('compare', {\n        page: page,\n        lines: lines,\n        title: 'Revisions compare',\n        revs: revs\n      })\n    } else {\n      res.locals.title = '404 - Not found'\n      res.statusCode = 404\n      res.render('404.jade')\n      return\n    }\n  })\n\n  var ldln = 0\n  var cdln\n\n  function leftDiffLineNumber (id, line) {\n    var li\n\n    switch (true) {\n      case line.slice(0, 2) === '@@':\n        li = line.match(/\\-(\\d+)/)[1]\n        ldln = parseInt(li, 10)\n        cdln = ldln\n        return '...'\n\n      case line.slice(0, 1) === '+':\n        return ''\n\n      case line.slice(0, 1) === '-':\n      default:\n        ldln++\n        cdln = ldln - 1\n        return cdln\n    }\n  }\n\n  var rdln = 0\n  function rightDiffLineNumber (id, line) {\n    var ri\n\n    switch (true) {\n      case line.slice(0, 2) === '@@':\n        ri = line.match(/\\+(\\d+)/)[1]\n        rdln = parseInt(ri, 10)\n        cdln = rdln\n        return '...'\n\n      case line.slice(0, 1) === '-':\n        return ' '\n\n      case line.slice(0, 1) === '+':\n      default:\n        rdln += 1\n        cdln = rdln - 1\n        return cdln\n    }\n  }\n\n  function lineClass (line) {\n    if (line.slice(0, 2) === '@@') {\n      return 'gc'\n    }\n    if (line.slice(0, 1) === '-') {\n      return 'gd'\n    }\n    if (line.slice(0, 1) === '+') {\n      return 'gi'\n    }\n  }\n}\n\nfunction _getIndex (req, res) {\n  res.redirect(proxyPath + '/wiki/' + app.locals.config.get('pages').index)\n}\n\nmodule.exports = router\n"}